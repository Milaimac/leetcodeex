- [等差数列划分 -- 如何用动态规划求解](#等差数列划分----如何用动态规划求解)
  - [等差数列划分 413](#等差数列划分-413)
    - [思考动态规划方程的思路](#思考动态规划方程的思路)
    - [dp要表达的意义是什么？](#dp要表达的意义是什么)
  - [等差数列划分 II 446](#等差数列划分-ii-446)
    - [思路过程](#思路过程)


# 等差数列划分 -- 如何用动态规划求解

## [等差数列划分 413](https://leetcode-cn.com/problems/arithmetic-slices/)

在使用动态规划之前，要先搞清除等差数列的性质

想必各位广大青年都很清楚，无非就是
- 一个数列 至少有三个元素
- 任意两个相邻元素之差相同
### 思考动态规划方程的思路
那么接下来的重点是如何利用这个性质去制作动态规划方程了，也就是思考我们要用dp来作为这个数列的什么？

举个例子思考

以「1,3,5」增长到「1,3，5,7」再增长到「1,3,5,7,9」。

通过从个例推导出普遍规律。

「1,3,5」的等差数列子序列肯定是它自己，也就是一个

「1,3,5,7」的等差数列子序列个数可以加上「1,3,5」原先包含的，然后再就是增加元素7之后增加的组合。增加的组合有「3,5,7」 「1,3,5,7」

其实现在已经找到规律了

**每次增加了一个数，子序列增加的个数是原先序列长度-1,**

为什么？因为等差数列的最小长度为3,那么增加7以后，「5,7」是不能作为一个等差数列的。那么如果按照增加子序列的长度递增，就会从「3,5,7」加到「1,3,5,7」。

而具体从 「1,3,5,7」增长到「1,3,5,7，9」还是让读者自己推把。
### dp要表达的意义是什么？
那其实现在如何用dp已经很明了了。我们不妨用dp来作为子序列增加的个数，这样在每次循环的时候，将dp加入总的结果sum去。

至于判断条件很简单，就是查看`nums[i] - nums[i-1]是否等于 nums[i-1]- nums[i-2]`

如果发现某个数前后不是等差的，设置为dp = 0。那直到遍历到等差的，设置dp = 1（也就是dp += 1）

```cpp
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& nums) {
        int dp = 0;
        int sum = 0;
        for(int i=2;i<nums.size();i++){
            if(nums[i] - nums[i-1] == nums[i-1] - nums[i-2]){
                dp += 1;
                sum += dp;
            }
            else{
                dp = 0;
            }
        }
        return sum;
    }
};
```


## [等差数列划分 II 446](https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/)


现在来看看等差数列划分的变种题。

### 思路过程
这和之前题不一样的是不要求是 **连续的**，可以中间删除某些数。

但是我们的思考过程也是一样的，就是dp被作为什么？用来表达什么的意义？

这样「2,4,6,8，10」 除了等差为2的数列，还有等差为4的数列。

也就是说，我们要把等差d这个概念作为dp的某个性质。既然这个dp已经有性质了，那么必然要使用能够表达性质的数据结构来承载dp。

这里由于等差d的范围很大，所以采用的是哈希表。

由于尾项和公差可以确定一个等差数列，因此我们定义状态 $f[i][d]$ 表示尾项为 $nums[i]$，公差为 $d$ 的弱等差子序列的个数。


```cpp
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& nums) {
        int n = nums.size();
        vector<unordered_map<long long,int>> f(n);
        int ans = 0;
        for(int i = 0;i<n;i++){          
            for(int j = 0;j<i;j++){
                long long d = 1LL * nums[i] - nums[j];                // 1LL为的是在计算时， 将int 转化为long long 
                auto it = f[j].find(d);                               //find找的是key
                int cnt = it == f[j].end() ? 0 :it->second;           //判断f[j]有多少个以d为公差的等差数列的元素
                ans += cnt;
                f[i][d] += cnt + 1;
            }
        }
        return ans;
    }
};
```


